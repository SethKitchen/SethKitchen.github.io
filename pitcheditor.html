<html>

<body>
    <div id="wrapper">
        <div style="height:50%; max-width: 100%; display:flex; overflow: scroll;">
            <div id="labels" style="float:left;">
                <p style="width:100px; font-size:10px; margin-top:20px;">B8 - (7902 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Bb8 - (7459 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">A8 - (7040 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Ab8 - (6645 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">G8 - (6272 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Gb8 - (5920 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">F8 - (5588 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">E8 - (5274 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Eb8 - (4978 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">D8 - (4699 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Db8 - (4434.9 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">C8 - (4186 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">B7 - (3951 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Bb7 - (3729 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">A7 - (3520 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Ab7 - (3322 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">G7 - (3136 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Gb7 - (2960 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">F7 - (2794 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">E7 - (2637 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Eb7 - (2489 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">D7 - (2349 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Db7 - (2217 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">C7 - (2093 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">B6 - (1976 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Bb6 - (1865 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">A6 - (1760 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Ab6 - (1661 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">G6 - (1568 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Gb6 - (1480 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">F6 - (1397 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">E6 - (1319 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Eb6 - (1245 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">D6 - (1175 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Db6 - (1109 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">C6 - (1047 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">B5 - (988 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Bb5 - (932 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">A5 - (880 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Ab5 - (831 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">G5 - (784 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Gb5 - (740 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">F5 - (698 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">E5 - (660 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Eb5 - (622 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">D5 - (587 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Db5 - (554 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">C5 - (523 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">B4 - (494 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Bb4 - (466 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">A4 - (440 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Ab4 - (415 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">G4 - (392 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Gb4 - (370 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">F4 - (349 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">E4 - (330 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Eb4 - (311 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">D4 - (294 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Db4 - (277 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">C4 - (262 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">B3 - (247 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Bb3 - (233 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">A3 - (220 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Ab3 - (208 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">G3 - (196 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Gb3 - (185 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">F3 - (175 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">E3 - (165 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Eb3 - (156 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">D3 - (147 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Db3 - (139 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">C3 - (131 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">B2 - (123 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Bb2 - (117 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">A2 - (110 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Ab2 - (104 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">G2 - (98.0 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Gb2 - (92.5 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">F2 - (87.3 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">E2 - (82.4 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Eb2 - (77.8 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">D2 - (73.4 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Db2 - (69.3 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">C2 - (65.4 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">B1 - (61.7 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Bb1 - (58.3 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">A1 - (55.0 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Ab1 - (51.9 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">G1 - (49.0 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Gb1 - (46.3 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">F1 - (43.7 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">E1 - (41.2 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Eb1 - (38.9 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">D1 - (36.7 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Db1 - (34.7 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">C1 - (32.7 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">B0 - (30.9 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Bb0 - (29.1 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">A0 - (27.5 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Ab0 - (26.0 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">G0 - (24.5 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Gb0 - (23.1 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">F0 - (21.8 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">E0 - (20.6 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Eb0 - (19.5 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">D0 - (18.4 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">Db0 - (17.3 Hz)</p>
                <p style="font-size:10px; margin-top:20px;">C0 - (16.4 Hz)</p>
            </div>
            <div style="float:left;">
                <canvas id="staff" width="2000px"></canvas>
            </div>
        </div>
        <div>
            <button style="width:200px; height:50px;" onclick="loadTheTrack()">Load The Track</button>
            <button style="width:200px; height:50px;" onclick="exportTrack()">Export The Track</button>
            <button style="width:200px; height:50px;" onclick="playPreview()">Play Preview</button>
        </div>
        <div>
            <h3>Update how many and which notes are displayed. Most likely tempo is calculated when track is loaded.</h2>
                <p>
                    Tempo (bpm): <input type="text" style="width:200px;" id="tempo" />
                </p>
                <p>
                    Samples per beat, defaults to 4 (i.e. 16th notes): <input type="text" style="width:200px;"
                        id="quant" value="4" />
                </p>
                <button onclick="getPitch()">Update</button>
        </div>
    </div>
</body>

</html>

<script>
    var canvas = null;
    var ctx = null;
    var audioCtx = null;
    var finalBuffer=null;

    var labelFrequencies = [7902, 7459, 7040, 6645, 6272, 5920, 5588, 5274, 4978, 4699, 4434.9, 4186, 3951, 3729, 3520,
        3322, 3136, 2960, 2794, 2637, 2489, 2349, 2217, 2093, 1976, 1865, 1760, 1661, 1568, 1480,
        1397, 1319, 1245, 1175, 1109, 1047, 988, 932, 880, 831, 784, 740, 698, 660, 622, 587, 554, 523, 494,
        466, 440, 415, 392, 370, 349, 330, 311, 294, 277, 262, 247, 233, 220, 208, 196, 185, 175, 165, 156, 147,
        139, 131, 123, 117, 110, 104, 98.0, 92.5, 87.3, 82.4, 77.8, 73.4, 69.3, 65.4, 61.7, 58.3, 55.0, 51.9,
        49.0, 46.3, 43.7, 41.2, 38.9, 36.7, 34.7, 32.7, 30.9, 29.1, 27.5, 26.0, 24.5, 23.1, 21.8, 20.6, 19.5, 18.4,
        17.3, 16.4].reverse();

    function ConvertFrequencyToCoordinate(freq) {
        if (!freq || freq < 1) {
            return 0;
        }
        else {
            var spaceBetweenEach = document.getElementById("staff").height / labelFrequencies.length;
            if (freq < labelFrequencies[0]) {
                return 0;
            }
            for (var i = 0; i < labelFrequencies.length - 1; i++) {
                if (labelFrequencies[i] < freq && labelFrequencies[i + 1] > freq) {
                    var max=labelFrequencies[i+1];
                    var min=labelFrequencies[i];
                    var extra=(spaceBetweenEach)/(max-min)*(freq-min);
                    console.log(extra);
                    return spaceBetweenEach * i+extra;
                }
            }
            return spaceBetweenEach * labelFrequencies.length;
        }
    }

    const DEFAULT_MIN_FREQUENCY = 82;
    const DEFAULT_MAX_FREQUENCY = 1000;
    const DEFAULT_RATIO = 5;
    const DEFAULT_SENSITIVITY = 0.1;
    const DEFAULT_TEMPO = 120;
    const DEFAULT_QUANTIZATION = 4;
    const DEFAULT_SAMPLE_RATE = 44100;
    const sampleRate = DEFAULT_SAMPLE_RATE;
    const minFrequency = DEFAULT_MIN_FREQUENCY;
    const maxFrequency = DEFAULT_MAX_FREQUENCY;
    const sensitivity = DEFAULT_SENSITIVITY;
    const ratio = DEFAULT_RATIO;
    const amd = [];
    var sourceNode = null;
    var analyser = null;
    var playSource=null;

    /* Round in such a way that both exact minPeriod as 
    exact maxPeriod lie inside the rounded span minPeriod-maxPeriod,
    thus ensuring that minFrequency and maxFrequency can be found
    even in edge cases */
    const maxPeriod = Math.ceil(sampleRate / minFrequency);
    const minPeriod = Math.floor(sampleRate / maxFrequency);
    var playing=false;

    function playPreview()
    {
        if(!playing)
        {
            playSource = audioCtx.createBufferSource();     // creates a sound source
            playSource.buffer = finalBuffer;                // tell the source which sound to play
            playSource.connect(audioCtx.destination);       // connect the source to the context's destination (the speakers)
            console.log('starting');
            playSource.start(0);                            // play the source now
            playing=true;
        }
        else
        {
            playSource.stop(0);
            playing=false;
        }
    }

    function pitchConsensus(detectors, chunk) {
        const pitches = detectors
            .map((fn) => fn(chunk))
            .filter(Boolean)
            .sort((a, b) => a < b ? -1 : 1);

        // In the case of one pitch, return it.
        if (pitches.length === 1) {
            return pitches[0];

            // In the case of two pitches, return the geometric mean if they
            // are close to each other, and the lower pitch otherwise.
        } else if (pitches.length === 2) {
            const [first, second] = pitches;
            return first * 2 > second ? Math.sqrt(first * second) : first;

            // In the case of three or more pitches, filter away the extremes
            // if they are very extreme, then take the geometric mean. 
        } else {
            const first = pitches[0];
            const second = pitches[1];
            const secondToLast = pitches[pitches.length - 2];
            const last = pitches[pitches.length - 1];

            const filtered1 = first * 2 > second ? pitches : pitches.slice(1);
            const filtered2 = secondToLast * 2 > last ? filtered1 : filtered1.slice(0, -1);
            return Math.pow(filtered2.reduce((t, p) => t * p, 1), 1 / filtered2.length);
        }
    }

    function frequencies(detector, float32AudioBuffer, options = {}) {

        const tempo = options.tempo || DEFAULT_TEMPO;
        const quantization = options.quantization || DEFAULT_QUANTIZATION;
        const sampleRate = audioCtx.sampleRate || DEFAULT_SAMPLE_RATE;

        const bufferLength = float32AudioBuffer.length;
        const chunkSize = Math.round((sampleRate * 60) / (quantization * tempo));

        let getPitch;
        if (Array.isArray(detector)) {
            getPitch = pitchConsensus.bind(null, detector);
        } else {
            getPitch = detector;
        }

        const pitches = [];
        for (let i = 0, max = bufferLength - chunkSize; i <= max; i += chunkSize) {
            const chunk = float32AudioBuffer.slice(i, i + chunkSize);
            const pitch = getPitch(chunk, audioCtx.sampleRate);
            pitches.push(pitch);
        }

        return pitches;
    };

    function AMDFDetector(float32AudioBuffer) {
        const maxShift = float32AudioBuffer.length;

        let t = 0;
        let minval = Infinity;
        let maxval = -Infinity;
        let frames1, frames2, calcSub, i, j, u, aux1, aux2;

        // Find the average magnitude difference for each possible period offset.
        for (i = 0; i < maxShift; i++) {
            if (minPeriod <= i && i <= maxPeriod) {
                for (aux1 = 0, aux2 = i, t = 0, frames1 = [], frames2 = []; aux1 < maxShift - i; t++ , aux2++ , aux1++) {
                    frames1[t] = float32AudioBuffer[aux1];
                    frames2[t] = float32AudioBuffer[aux2];
                }

                // Take the difference between these frames.
                const frameLength = frames1.length;
                calcSub = [];
                for (u = 0; u < frameLength; u++) {
                    calcSub[u] = frames1[u] - frames2[u];
                }

                // Sum the differences.
                let summation = 0;
                for (u = 0; u < frameLength; u++) {
                    summation += Math.abs(calcSub[u]);
                }
                amd[i] = summation;
            }
        }

        for (j = minPeriod; j < maxPeriod; j++) {
            if (amd[j] < minval) minval = amd[j];
            if (amd[j] > maxval) maxval = amd[j];
        }

        const cutoff = Math.round((sensitivity * (maxval - minval)) + minval);
        for (j = minPeriod; j <= maxPeriod && amd[j] > cutoff; j++);

        const search_length = minPeriod / 2;
        minval = amd[j];
        let minpos = j;
        for (i = j - 1; i < j + search_length && i <= maxPeriod; i++) {
            if (amd[i] < minval) {
                minval = amd[i];
                minpos = i;
            }
        }

        if (Math.round(amd[minpos] * ratio) < maxval) {
            return sampleRate / minpos;
        } else {
            return null;
        }
    }

    function loadTheTrack() {
        var input = document.createElement('input');
        input.type = 'file';
        input.style = "display:none";
        input.onchange = function (e) {
            var file = e.target.files[0];
            console.log(file);
            var reader = new FileReader();
            reader.onload = function () {
                console.log("decoding audio data with" + this.result);
                audioCtx.decodeAudioData(this.result, (decodedData) => {
                    console.log(decodedData);
                    // note: on older systems, may have to use deprecated noteOn(time);
                    finalBuffer=decodedData;
                    getBpm();
                    getPitch();
                }, (e) => {
                    alert('Sorry this browser unable to download this file... try Chrome');
                });
            }
            reader.readAsArrayBuffer(file);
        }
        document.getElementById("wrapper").appendChild(input);
        input.click();
    }

    function YINDetector(float32AudioBuffer) {
        const DEFAULT_THRESHOLD = 0.10;
        const DEFAULT_PROBABILITY_THRESHOLD = 0.1;
        const threshold = DEFAULT_THRESHOLD;
        const probabilityThreshold = DEFAULT_PROBABILITY_THRESHOLD;
        // Set buffer size to the highest power of two below the provided buffer's length.
        let bufferSize;
        for (bufferSize = 1; bufferSize < float32AudioBuffer.length; bufferSize *= 2);
        bufferSize /= 2;

        // Set up the yinBuffer as described in step one of the YIN paper.
        const yinBufferLength = bufferSize / 2;
        const yinBuffer = new Float32Array(yinBufferLength);

        let probability, tau;

        // Compute the difference function as described in step 2 of the YIN paper.
        for (let t = 0; t < yinBufferLength; t++) {
            yinBuffer[t] = 0;
        }
        for (let t = 1; t < yinBufferLength; t++) {
            for (let i = 0; i < yinBufferLength; i++) {
                const delta = float32AudioBuffer[i] - float32AudioBuffer[i + t];
                yinBuffer[t] += delta * delta;
            }
        }

        // Compute the cumulative mean normalized difference as described in step 3 of the paper.
        yinBuffer[0] = 1;
        yinBuffer[1] = 1;
        let runningSum = 0;
        for (let t = 1; t < yinBufferLength; t++) {
            runningSum += yinBuffer[t];
            yinBuffer[t] *= t / runningSum;
        }

        // Compute the absolute threshold as described in step 4 of the paper.
        // Since the first two positions in the array are 1,
        // we can start at the third position.
        for (tau = 2; tau < yinBufferLength; tau++) {
            if (yinBuffer[tau] < threshold) {
                while (tau + 1 < yinBufferLength && yinBuffer[tau + 1] < yinBuffer[tau]) {
                    tau++;
                }
                // found tau, exit loop and return
                // store the probability
                // From the YIN paper: The threshold determines the list of
                // candidates admitted to the set, and can be interpreted as the
                // proportion of aperiodic power tolerated
                // within a periodic signal.
                //
                // Since we want the periodicity and and not aperiodicity:
                // periodicity = 1 - aperiodicity
                probability = 1 - yinBuffer[tau];
                break;
            }
        }

        // if no pitch found, return null.
        if (tau == yinBufferLength || yinBuffer[tau] >= threshold) {
            return null;
        }

        // If probability too low, return -1.
        if (probability < probabilityThreshold) {
            return null;
        }


        /**
         * Implements step 5 of the AUBIO_YIN paper. It refines the estimated tau
         * value using parabolic interpolation. This is needed to detect higher
         * frequencies more precisely. See http://fizyka.umk.pl/nrbook/c10-2.pdf and
         * for more background
         * http://fedc.wiwi.hu-berlin.de/xplore/tutorials/xegbohtmlnode62.html
         */
        let betterTau, x0, x2;
        if (tau < 1) {
            x0 = tau;
        } else {
            x0 = tau - 1;
        }
        if (tau + 1 < yinBufferLength) {
            x2 = tau + 1;
        } else {
            x2 = tau;
        }
        if (x0 === tau) {
            if (yinBuffer[tau] <= yinBuffer[x2]) {
                betterTau = tau;
            } else {
                betterTau = x2;
            }
        } else if (x2 === tau) {
            if (yinBuffer[tau] <= yinBuffer[x0]) {
                betterTau = tau;
            } else {
                betterTau = x0;
            }
        } else {
            const s0 = yinBuffer[x0];
            const s1 = yinBuffer[tau];
            const s2 = yinBuffer[x2];
            // fixed AUBIO implementation, thanks to Karl Helgason:
            // (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1
            betterTau = tau + (s2 - s0) / (2 * (2 * s1 - s2 - s0));
        }

        return sampleRate / betterTau;
    }

    var buflen = 1024;
    var buf = new Float32Array(buflen);

    var noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];

    function noteFromPitch(frequency) {
        var noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
        return Math.round(noteNum) + 69;
    }

    function frequencyFromNoteNumber(note) {
        return 440 * Math.pow(2, (note - 69) / 12);
    }

    function centsOffFromPitch(frequency, note) {
        return Math.floor(1200 * Math.log(frequency / frequencyFromNoteNumber(note)) / Math.log(2));
    }

    var MIN_SAMPLES = 0;  // will be initialized when AudioContext is created.
    var GOOD_ENOUGH_CORRELATION = 0.9; // this is the "bar" for how close a correlation needs to be

    function autoCorrelate(buf, sampleRate) {
        var SIZE = buf.length;
        var MAX_SAMPLES = Math.floor(SIZE / 2);
        var best_offset = -1;
        var best_correlation = 0;
        var rms = 0;
        var foundGoodCorrelation = false;
        var correlations = new Array(MAX_SAMPLES);

        for (var i = 0; i < SIZE; i++) {
            var val = buf[i];
            rms += val * val;
        }
        rms = Math.sqrt(rms / SIZE);
        if (rms < 0.01) // not enough signal
            return -1;

        var lastCorrelation = 1;
        for (var offset = MIN_SAMPLES; offset < MAX_SAMPLES; offset++) {
            var correlation = 0;

            for (var i = 0; i < MAX_SAMPLES; i++) {
                correlation += Math.abs((buf[i]) - (buf[i + offset]));
            }
            correlation = 1 - (correlation / MAX_SAMPLES);
            correlations[offset] = correlation; // store it, for the tweaking we need to do below.
            if ((correlation > GOOD_ENOUGH_CORRELATION) && (correlation > lastCorrelation)) {
                foundGoodCorrelation = true;
                if (correlation > best_correlation) {
                    best_correlation = correlation;
                    best_offset = offset;
                }
            } else if (foundGoodCorrelation) {
                // short-circuit - we found a good correlation, then a bad one, so we'd just be seeing copies from here.
                // Now we need to tweak the offset - by interpolating between the values to the left and right of the
                // best offset, and shifting it a bit.  This is complex, and HACKY in this code (happy to take PRs!) -
                // we need to do a curve fit on correlations[] around best_offset in order to better determine precise
                // (anti-aliased) offset.

                // we know best_offset >=1, 
                // since foundGoodCorrelation cannot go to true until the second pass (offset=1), and 
                // we can't drop into this clause until the following pass (else if).
                var shift = (correlations[best_offset + 1] - correlations[best_offset - 1]) / correlations[best_offset];
                return sampleRate / (best_offset + (8 * shift));
            }
            lastCorrelation = correlation;
        }
        if (best_correlation > 0.01) {
            // console.log("f = " + sampleRate/best_offset + "Hz (rms: " + rms + " confidence: " + best_correlation + ")")
            return sampleRate / best_offset;
        }
        return -1;
        //	var best_frequency = sampleRate/best_offset;
    }

    function updatePitch(time) {
        var cycles = new Array;
        analyser.getFloatTimeDomainData(buf);
        var ac = autoCorrelate(buf, audioCtx.sampleRate);
        pitch = ac;
        if (pitch && !isNaN(pitch) && pitch > 0) {
            console.log(Math.round(pitch));
        }
        var note = noteFromPitch(pitch);
        if (note && !isNaN(note) && note > 0) {
            console.log(noteStrings[note % 12]);
        }
        var detune = centsOffFromPitch(pitch, note);
        //console.log(detune);
        if (detune == 0) {
            detuneElem.className = "";
            detuneAmount.innerHTML = "--";
        } else {
            if (detune < 0)
                console.log("flat");
            else
                console.log("sharp");
            console.log(Math.abs(detune));
        }

        if (!window.requestAnimationFrame)
            window.requestAnimationFrame = window.webkitRequestAnimationFrame;
        rafID = window.requestAnimationFrame(updatePitch);
    }

    function getPitch() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        const detectPitch = autoCorrelate; // null if pitch cannot be 
        const resultFrequencies = frequencies(detectPitch, finalBuffer.getChannelData(0), {
            tempo: document.getElementById('tempo').value, // in BPM, defaults to 120
            quantization: document.getElementById('quant').value, // samples per beat, defaults to 4 (i.e. 16th notes)
        });
        console.log(resultFrequencies);
        document.getElementById('staff').width = resultFrequencies.length*10+15;
        document.getElementById('staff').style.width = resultFrequencies.length*10+15+'px';
        document.getElementById('staff').height=document.getElementById('labels').scrollHeight;
        document.getElementById('staff').style.height=document.getElementById('labels').scrollHeight+'px';
        for (var i = 0; i < resultFrequencies.length; i++) {
            var y = document.getElementById('staff').height - ConvertFrequencyToCoordinate(resultFrequencies[i]);
            var x = (i * 10) + 5;
            ctx.fillRect(x, y, 3, 3); // fill in the pixel at (10,10)
        }
    }

    window.onload = function () {
        canvas = document.getElementById("staff");
        ctx = canvas.getContext('2d');
        while (!audioCtx) {
            var AudioContext = window.AudioContext || window.webkitAudioContext;
            audioCtx = new AudioContext();
        }
    }

    function getPeaks(data) {
        // What we're going to do here, is to divide up our audio into parts.

        // We will then identify, for each part, what the loudest sample is in that
        // part.

        // It's implied that that sample would represent the most likely 'beat'
        // within that part.

        // Each part is 0.5 seconds long - or 22,050 samples.

        // This will give us 60 'beats' - we will only take the loudest half of
        // those.

        // This will allow us to ignore breaks, and allow us to address tracks with
        // a BPM below 120.

        var partSize = 22050,
            parts = data[0].length / partSize,
            peaks = [];

        for (var i = 0; i < parts; i++) {
            var max = 0;
            for (var j = i * partSize; j < (i + 1) * partSize; j++) {
                var volume = Math.max(Math.abs(data[0][j]), Math.abs(data[1][j]));
                if (!max || (volume > max.volume)) {
                    max = {
                        position: j,
                        volume: volume
                    };
                }
            }
            peaks.push(max);
        }

        // We then sort the peaks according to volume...

        peaks.sort(function (a, b) {
            return b.volume - a.volume;
        });

        // ...take the loundest half of those...

        peaks = peaks.splice(0, peaks.length * 0.5);

        // ...and re-sort it back based on position.

        peaks.sort(function (a, b) {
            return a.position - b.position;
        });

        return peaks;
    }

    function upshiftSelected() {

    }

    function getIntervals(peaks) {

        // What we now do is get all of our peaks, and then measure the distance to
        // other peaks, to create intervals.  Then based on the distance between
        // those peaks (the distance of the intervals) we can calculate the BPM of
        // that particular interval.

        // The interval that is seen the most should have the BPM that corresponds
        // to the track itself.

        var groups = [];

        peaks.forEach(function (peak, index) {
            for (var i = 1; (index + i) < peaks.length && i < 10; i++) {
                var group = {
                    tempo: (60 * 44100) / (peaks[index + i].position - peak.position),
                    count: 1
                };

                while (group.tempo < 90) {
                    group.tempo *= 2;
                }

                while (group.tempo > 180) {
                    group.tempo /= 2;
                }

                group.tempo = Math.round(group.tempo);

                if (!(groups.some(function (interval) {
                    return (interval.tempo === group.tempo ? interval.count++ : 0);
                }))) {
                    groups.push(group);
                }
            }
        });
        return groups;
    }

    function getBpm() {
        if (finalBuffer != null) {
            // Create offline context
            var OfflineContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;
            var offCtx = new OfflineContext(2, 30 * 44100, 44100);

            // see below for optional constructor parameters.
            var buffer = finalBuffer;
            // Create buffer source
            var source = offCtx.createBufferSource();
            source.buffer = buffer;

            // Beats, or kicks, generally occur around the 100 to 150 hz range.
            // Below this is often the bassline.  So let's focus just on that.

            // First a lowpass to remove most of the song.

            var lowpass = offCtx.createBiquadFilter();
            lowpass.type = "lowpass";
            lowpass.frequency.value = 150;
            lowpass.Q.value = 1;

            // Run the output of the source through the low pass.
            source.connect(lowpass);

            // Now a highpass to remove the bassline.
            var highpass = offCtx.createBiquadFilter();
            highpass.type = "highpass";
            highpass.frequency.value = 100;
            highpass.Q.value = 1;

            // Run the output of the lowpass through the highpass.
            lowpass.connect(highpass);

            // Run the output of the highpass through our offline context.
            highpass.connect(offCtx.destination);

            // Start the source, and render the output into the offline conext.
            source.start(0);
            offCtx.startRendering();

            offCtx.oncomplete = function (e) {
                var buffer = e.renderedBuffer;
                var peaks = getPeaks([buffer.getChannelData(0), buffer.getChannelData(1)]);
                var groups = getIntervals(peaks);

                var top = groups.sort(function (intA, intB) {
                    return intB.count - intA.count;
                }).splice(0, 5);
                document.getElementById('tempo').value = Math.round(top[0].tempo);
            }
        }
    }
</script>